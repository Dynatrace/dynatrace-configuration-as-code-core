/*
Automation

Automation API allows working with workflows and various trigger options.

API version: 1.464.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package automation

import (
	"encoding/json"
)

// checks if the GroupingRule type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &GroupingRule{}

// GroupingRule struct for GroupingRule
type GroupingRule struct {
	Combine   []string `json:"combine,omitempty"`
	Intersect []string `json:"intersect,omitempty"`
	Subtract  []string `json:"subtract,omitempty"`
}

// NewGroupingRule instantiates a new GroupingRule object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewGroupingRule() *GroupingRule {
	this := GroupingRule{}
	return &this
}

// NewGroupingRuleWithDefaults instantiates a new GroupingRule object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewGroupingRuleWithDefaults() *GroupingRule {
	this := GroupingRule{}
	return &this
}

// GetCombine returns the Combine field value if set, zero value otherwise.
func (o *GroupingRule) GetCombine() []string {
	if o == nil || IsNil(o.Combine) {
		var ret []string
		return ret
	}
	return o.Combine
}

// GetCombineOk returns a tuple with the Combine field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GroupingRule) GetCombineOk() ([]string, bool) {
	if o == nil || IsNil(o.Combine) {
		return nil, false
	}
	return o.Combine, true
}

// HasCombine returns a boolean if a field has been set.
func (o *GroupingRule) HasCombine() bool {
	if o != nil && !IsNil(o.Combine) {
		return true
	}

	return false
}

// SetCombine gets a reference to the given []string and assigns it to the Combine field.
func (o *GroupingRule) SetCombine(v []string) {
	o.Combine = v
}

// GetIntersect returns the Intersect field value if set, zero value otherwise.
func (o *GroupingRule) GetIntersect() []string {
	if o == nil || IsNil(o.Intersect) {
		var ret []string
		return ret
	}
	return o.Intersect
}

// GetIntersectOk returns a tuple with the Intersect field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GroupingRule) GetIntersectOk() ([]string, bool) {
	if o == nil || IsNil(o.Intersect) {
		return nil, false
	}
	return o.Intersect, true
}

// HasIntersect returns a boolean if a field has been set.
func (o *GroupingRule) HasIntersect() bool {
	if o != nil && !IsNil(o.Intersect) {
		return true
	}

	return false
}

// SetIntersect gets a reference to the given []string and assigns it to the Intersect field.
func (o *GroupingRule) SetIntersect(v []string) {
	o.Intersect = v
}

// GetSubtract returns the Subtract field value if set, zero value otherwise.
func (o *GroupingRule) GetSubtract() []string {
	if o == nil || IsNil(o.Subtract) {
		var ret []string
		return ret
	}
	return o.Subtract
}

// GetSubtractOk returns a tuple with the Subtract field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GroupingRule) GetSubtractOk() ([]string, bool) {
	if o == nil || IsNil(o.Subtract) {
		return nil, false
	}
	return o.Subtract, true
}

// HasSubtract returns a boolean if a field has been set.
func (o *GroupingRule) HasSubtract() bool {
	if o != nil && !IsNil(o.Subtract) {
		return true
	}

	return false
}

// SetSubtract gets a reference to the given []string and assigns it to the Subtract field.
func (o *GroupingRule) SetSubtract(v []string) {
	o.Subtract = v
}

func (o GroupingRule) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o GroupingRule) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Combine) {
		toSerialize["combine"] = o.Combine
	}
	if !IsNil(o.Intersect) {
		toSerialize["intersect"] = o.Intersect
	}
	if !IsNil(o.Subtract) {
		toSerialize["subtract"] = o.Subtract
	}
	return toSerialize, nil
}

type NullableGroupingRule struct {
	value *GroupingRule
	isSet bool
}

func (v NullableGroupingRule) Get() *GroupingRule {
	return v.value
}

func (v *NullableGroupingRule) Set(val *GroupingRule) {
	v.value = val
	v.isSet = true
}

func (v NullableGroupingRule) IsSet() bool {
	return v.isSet
}

func (v *NullableGroupingRule) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableGroupingRule(val *GroupingRule) *NullableGroupingRule {
	return &NullableGroupingRule{value: val, isSet: true}
}

func (v NullableGroupingRule) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableGroupingRule) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
