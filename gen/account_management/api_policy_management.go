/*
Dynatrace Account Management API

The enterprise management API for Dynatrace SaaS enables automation of operational tasks related to user access and environment lifecycle management.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package accountmanagement

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// PolicyManagementAPIService PolicyManagementAPI service
type PolicyManagementAPIService service

type ApiAppendLevelPolicyBindingsRequest struct {
	ctx                                 context.Context
	ApiService                          *PolicyManagementAPIService
	policyUuid                          interface{}
	levelId                             interface{}
	levelType                           interface{}
	appendLevelPolicyBindingsRequestDto *AppendLevelPolicyBindingsRequestDto
}

// The JSON body of the request. Contains user groups that must use the policy and optional boundaries.
func (r ApiAppendLevelPolicyBindingsRequest) AppendLevelPolicyBindingsRequestDto(appendLevelPolicyBindingsRequestDto AppendLevelPolicyBindingsRequestDto) ApiAppendLevelPolicyBindingsRequest {
	r.appendLevelPolicyBindingsRequestDto = &appendLevelPolicyBindingsRequestDto
	return r
}

func (r ApiAppendLevelPolicyBindingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppendLevelPolicyBindingsExecute(r)
}

/*
AppendLevelPolicyBindings Adds policy bindings to a level

Existing bindings remain unaffected.
This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiAppendLevelPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) AppendLevelPolicyBindings(ctx context.Context, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiAppendLevelPolicyBindingsRequest {
	return ApiAppendLevelPolicyBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) AppendLevelPolicyBindingsExecute(r ApiAppendLevelPolicyBindingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.AppendLevelPolicyBindings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appendLevelPolicyBindingsRequestDto == nil {
		return nil, reportError("appendLevelPolicyBindingsRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appendLevelPolicyBindingsRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppendParticularGroupBindingRequest struct {
	ctx                                 context.Context
	ApiService                          *PolicyManagementAPIService
	groupUuid                           interface{}
	policyUuid                          interface{}
	levelId                             interface{}
	levelType                           interface{}
	appendLevelPolicyBindingForGroupDto *AppendLevelPolicyBindingForGroupDto
}

// The JSON body of the request. Contains parameters, metadata and boundaries
func (r ApiAppendParticularGroupBindingRequest) AppendLevelPolicyBindingForGroupDto(appendLevelPolicyBindingForGroupDto AppendLevelPolicyBindingForGroupDto) ApiAppendParticularGroupBindingRequest {
	r.appendLevelPolicyBindingForGroupDto = &appendLevelPolicyBindingForGroupDto
	return r
}

func (r ApiAppendParticularGroupBindingRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppendParticularGroupBindingExecute(r)
}

/*
AppendParticularGroupBinding Append policy bindings within a level for a user group

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid The ID of the required user group.
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiAppendParticularGroupBindingRequest
*/
func (a *PolicyManagementAPIService) AppendParticularGroupBinding(ctx context.Context, groupUuid interface{}, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiAppendParticularGroupBindingRequest {
	return ApiAppendParticularGroupBindingRequest{
		ApiService: a,
		ctx:        ctx,
		groupUuid:  groupUuid,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) AppendParticularGroupBindingExecute(r ApiAppendParticularGroupBindingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.AppendParticularGroupBinding")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appendLevelPolicyBindingForGroupDto == nil {
		return nil, reportError("appendLevelPolicyBindingForGroupDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appendLevelPolicyBindingForGroupDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateLevelPolicyRequest struct {
	ctx                                 context.Context
	ApiService                          *PolicyManagementAPIService
	levelId                             interface{}
	levelType                           interface{}
	createOrUpdateLevelPolicyRequestDto *CreateOrUpdateLevelPolicyRequestDto
}

// The JSON body of the request. Contains the configuration of a new policy.
func (r ApiCreateLevelPolicyRequest) CreateOrUpdateLevelPolicyRequestDto(createOrUpdateLevelPolicyRequestDto CreateOrUpdateLevelPolicyRequestDto) ApiCreateLevelPolicyRequest {
	r.createOrUpdateLevelPolicyRequestDto = &createOrUpdateLevelPolicyRequestDto
	return r
}

func (r ApiCreateLevelPolicyRequest) Execute() (*LevelPolicyDto, *http.Response, error) {
	return r.ApiService.CreateLevelPolicyExecute(r)
}

/*
CreateLevelPolicy Creates a new policy

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiCreateLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) CreateLevelPolicy(ctx context.Context, levelId interface{}, levelType interface{}) ApiCreateLevelPolicyRequest {
	return ApiCreateLevelPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return LevelPolicyDto
func (a *PolicyManagementAPIService) CreateLevelPolicyExecute(r ApiCreateLevelPolicyRequest) (*LevelPolicyDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LevelPolicyDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.CreateLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateLevelPolicyRequestDto == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateLevelPolicyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateLevelPolicyRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteLevelPolicyRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	force      *interface{}
	policyUuid interface{}
	levelId    interface{}
	levelType  interface{}
}

// Set to &#x60;true&#x60; to delete a policy that is still in use.
func (r ApiDeleteLevelPolicyRequest) Force(force interface{}) ApiDeleteLevelPolicyRequest {
	r.force = &force
	return r
}

func (r ApiDeleteLevelPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLevelPolicyExecute(r)
}

/*
DeleteLevelPolicy Deletes a policy

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiDeleteLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) DeleteLevelPolicy(ctx context.Context, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiDeleteLevelPolicyRequest {
	return ApiDeleteLevelPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) DeleteLevelPolicyExecute(r ApiDeleteLevelPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.DeleteLevelPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.force == nil {
		return nil, reportError("force is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLevelPolicyBindingsRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	levelId    interface{}
	levelType  interface{}
}

func (r ApiDeleteLevelPolicyBindingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLevelPolicyBindingsExecute(r)
}

/*
DeleteLevelPolicyBindings Deletes all policy bindings from a level

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiDeleteLevelPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) DeleteLevelPolicyBindings(ctx context.Context, levelId interface{}, levelType interface{}) ApiDeleteLevelPolicyBindingsRequest {
	return ApiDeleteLevelPolicyBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) DeleteLevelPolicyBindingsExecute(r ApiDeleteLevelPolicyBindingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.DeleteLevelPolicyBindings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLevelPolicyBindingsForPolicyRequest struct {
	ctx           context.Context
	ApiService    *PolicyManagementAPIService
	forceMultiple *interface{}
	policyUuid    interface{}
	levelId       interface{}
	levelType     interface{}
	queryParams   *map[string]interface{}
}

// Forces multiple in case delete by parameters and metadata query
func (r ApiDeleteLevelPolicyBindingsForPolicyRequest) ForceMultiple(forceMultiple interface{}) ApiDeleteLevelPolicyBindingsForPolicyRequest {
	r.forceMultiple = &forceMultiple
	return r
}

// Key-value pairs for policy template parameters and metadata. Only bindings matching given parameters and metadata will be updated or deleted.
func (r ApiDeleteLevelPolicyBindingsForPolicyRequest) QueryParams(queryParams map[string]interface{}) ApiDeleteLevelPolicyBindingsForPolicyRequest {
	r.queryParams = &queryParams
	return r
}

func (r ApiDeleteLevelPolicyBindingsForPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLevelPolicyBindingsForPolicyExecute(r)
}

/*
DeleteLevelPolicyBindingsForPolicy Deletes all bindings of a policy

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiDeleteLevelPolicyBindingsForPolicyRequest
*/
func (a *PolicyManagementAPIService) DeleteLevelPolicyBindingsForPolicy(ctx context.Context, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiDeleteLevelPolicyBindingsForPolicyRequest {
	return ApiDeleteLevelPolicyBindingsForPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) DeleteLevelPolicyBindingsForPolicyExecute(r ApiDeleteLevelPolicyBindingsForPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.DeleteLevelPolicyBindingsForPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forceMultiple == nil {
		return nil, reportError("forceMultiple is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "forceMultiple", r.forceMultiple, "form", "")
	if r.queryParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query-params", r.queryParams, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest struct {
	ctx           context.Context
	ApiService    *PolicyManagementAPIService
	forceMultiple *interface{}
	groupUuid     interface{}
	policyUuid    interface{}
	levelId       interface{}
	levelType     interface{}
	queryParams   *map[string]interface{}
}

// Forces multiple in case delete by parameters and metadata query
func (r ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest) ForceMultiple(forceMultiple interface{}) ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest {
	r.forceMultiple = &forceMultiple
	return r
}

// Key-value pairs for policy template parameters and metadata. Only bindings matching given parameters and metadata will be updated or deleted.
func (r ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest) QueryParams(queryParams map[string]interface{}) ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest {
	r.queryParams = &queryParams
	return r
}

func (r ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLevelPolicyBindingsForPolicyAndGroupExecute(r)
}

/*
DeleteLevelPolicyBindingsForPolicyAndGroup Deletes a policy binding from a user group

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid The ID of the required user group.
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest
*/
func (a *PolicyManagementAPIService) DeleteLevelPolicyBindingsForPolicyAndGroup(ctx context.Context, groupUuid interface{}, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest {
	return ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupUuid:  groupUuid,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) DeleteLevelPolicyBindingsForPolicyAndGroupExecute(r ApiDeleteLevelPolicyBindingsForPolicyAndGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.DeleteLevelPolicyBindingsForPolicyAndGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forceMultiple == nil {
		return nil, reportError("forceMultiple is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "forceMultiple", r.forceMultiple, "form", "")
	if r.queryParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query-params", r.queryParams, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletePolicyBoundaryRequest struct {
	ctx                context.Context
	ApiService         *PolicyManagementAPIService
	policyBoundaryUuid interface{}
	accountId          interface{}
}

func (r ApiDeletePolicyBoundaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePolicyBoundaryExecute(r)
}

/*
DeletePolicyBoundary Delete policy boundary by uuid within a level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyBoundaryUuid The ID of the required boundary.
	@param accountId The ID of the policy boundary level. Use the UUID of the account.
	@return ApiDeletePolicyBoundaryRequest
*/
func (a *PolicyManagementAPIService) DeletePolicyBoundary(ctx context.Context, policyBoundaryUuid interface{}, accountId interface{}) ApiDeletePolicyBoundaryRequest {
	return ApiDeletePolicyBoundaryRequest{
		ApiService:         a,
		ctx:                ctx,
		policyBoundaryUuid: policyBoundaryUuid,
		accountId:          accountId,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) DeletePolicyBoundaryExecute(r ApiDeletePolicyBoundaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.DeletePolicyBoundary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/account/{accountId}/boundaries/{policyBoundaryUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyBoundaryUuid"+"}", url.PathEscape(parameterValueToString(r.policyBoundaryUuid, "policyBoundaryUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllLevelPoliciesBindingsRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	levelId    interface{}
	levelType  interface{}
}

func (r ApiGetAllLevelPoliciesBindingsRequest) Execute() (*LevelPolicyBindingDto, *http.Response, error) {
	return r.ApiService.GetAllLevelPoliciesBindingsExecute(r)
}

/*
GetAllLevelPoliciesBindings Lists all policy bindings of a level

A policy binding shows which user groups use the policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetAllLevelPoliciesBindingsRequest
*/
func (a *PolicyManagementAPIService) GetAllLevelPoliciesBindings(ctx context.Context, levelId interface{}, levelType interface{}) ApiGetAllLevelPoliciesBindingsRequest {
	return ApiGetAllLevelPoliciesBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return LevelPolicyBindingDto
func (a *PolicyManagementAPIService) GetAllLevelPoliciesBindingsExecute(r ApiGetAllLevelPoliciesBindingsRequest) (*LevelPolicyBindingDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LevelPolicyBindingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetAllLevelPoliciesBindings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEffectivePermissionsRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	entityId   *interface{}
	entityType *interface{}
	levelId    interface{}
	levelType  interface{}
	size       *interface{}
	page       *interface{}
	services   *interface{}
}

// Required entity id.
func (r ApiGetEffectivePermissionsRequest) EntityId(entityId interface{}) ApiGetEffectivePermissionsRequest {
	r.entityId = &entityId
	return r
}

// Required entity type. The following values are available:   * user  * group
func (r ApiGetEffectivePermissionsRequest) EntityType(entityType interface{}) ApiGetEffectivePermissionsRequest {
	r.entityType = &entityType
	return r
}

func (r ApiGetEffectivePermissionsRequest) Size(size interface{}) ApiGetEffectivePermissionsRequest {
	r.size = &size
	return r
}

func (r ApiGetEffectivePermissionsRequest) Page(page interface{}) ApiGetEffectivePermissionsRequest {
	r.page = &page
	return r
}

// Optional services list. Policies for given services will be returned
func (r ApiGetEffectivePermissionsRequest) Services(services interface{}) ApiGetEffectivePermissionsRequest {
	r.services = &services
	return r
}

func (r ApiGetEffectivePermissionsRequest) Execute() (*EffectivePermissions, *http.Response, error) {
	return r.ApiService.GetEffectivePermissionsExecute(r)
}

/*
GetEffectivePermissions Gets effective permissions for a user or group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetEffectivePermissionsRequest
*/
func (a *PolicyManagementAPIService) GetEffectivePermissions(ctx context.Context, levelId interface{}, levelType interface{}) ApiGetEffectivePermissionsRequest {
	return ApiGetEffectivePermissionsRequest{
		ApiService: a,
		ctx:        ctx,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return EffectivePermissions
func (a *PolicyManagementAPIService) GetEffectivePermissionsExecute(r ApiGetEffectivePermissionsRequest) (*EffectivePermissions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EffectivePermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetEffectivePermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/resolution/{levelType}/{levelId}/effectivepermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entityId == nil {
		return localVarReturnValue, nil, reportError("entityId is required and must be specified")
	}
	if r.entityType == nil {
		return localVarReturnValue, nil, reportError("entityType is required and must be specified")
	}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue interface{} = 100
		r.size = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue interface{} = 1
		r.page = &defaultValue
	}
	if r.services != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "services", r.services, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "entityId", r.entityId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "entityType", r.entityType, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLevelDescendantsPolicyBindingsRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	policyUuid interface{}
	levelId    interface{}
	levelType  interface{}
	size       *interface{}
	page       *interface{}
}

func (r ApiGetLevelDescendantsPolicyBindingsRequest) Size(size interface{}) ApiGetLevelDescendantsPolicyBindingsRequest {
	r.size = &size
	return r
}

func (r ApiGetLevelDescendantsPolicyBindingsRequest) Page(page interface{}) ApiGetLevelDescendantsPolicyBindingsRequest {
	r.page = &page
	return r
}

func (r ApiGetLevelDescendantsPolicyBindingsRequest) Execute() (*LevelPolicyBindingDtoList, *http.Response, error) {
	return r.ApiService.GetLevelDescendantsPolicyBindingsExecute(r)
}

/*
GetLevelDescendantsPolicyBindings Get policy bindings within descendants of a level

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.   Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetLevelDescendantsPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) GetLevelDescendantsPolicyBindings(ctx context.Context, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiGetLevelDescendantsPolicyBindingsRequest {
	return ApiGetLevelDescendantsPolicyBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return LevelPolicyBindingDtoList
func (a *PolicyManagementAPIService) GetLevelDescendantsPolicyBindingsExecute(r ApiGetLevelDescendantsPolicyBindingsRequest) (*LevelPolicyBindingDtoList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LevelPolicyBindingDtoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetLevelDescendantsPolicyBindings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/descendants/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue interface{} = 100
		r.size = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue interface{} = 1
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLevelPoliciesRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	levelId    interface{}
	levelType  interface{}
	categories *interface{}
	name       *interface{}
}

// Optional policy categories set. Only policies that match given categories will be returned.
func (r ApiGetLevelPoliciesRequest) Categories(categories interface{}) ApiGetLevelPoliciesRequest {
	r.categories = &categories
	return r
}

// Optional policy name. Only policies that are of equal name will be returned.
func (r ApiGetLevelPoliciesRequest) Name(name interface{}) ApiGetLevelPoliciesRequest {
	r.name = &name
	return r
}

func (r ApiGetLevelPoliciesRequest) Execute() (*PolicyDtoList, *http.Response, error) {
	return r.ApiService.GetLevelPoliciesExecute(r)
}

/*
GetLevelPolicies Lists all native policies of a level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetLevelPoliciesRequest
*/
func (a *PolicyManagementAPIService) GetLevelPolicies(ctx context.Context, levelId interface{}, levelType interface{}) ApiGetLevelPoliciesRequest {
	return ApiGetLevelPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return PolicyDtoList
func (a *PolicyManagementAPIService) GetLevelPoliciesExecute(r ApiGetLevelPoliciesRequest) (*PolicyDtoList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyDtoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetLevelPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.categories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categories", r.categories, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLevelPolicyRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	policyUuid interface{}
	levelId    interface{}
	levelType  interface{}
}

func (r ApiGetLevelPolicyRequest) Execute() (*LevelPolicyDto, *http.Response, error) {
	return r.ApiService.GetLevelPolicyExecute(r)
}

/*
GetLevelPolicy Gets a policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) GetLevelPolicy(ctx context.Context, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiGetLevelPolicyRequest {
	return ApiGetLevelPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return LevelPolicyDto
func (a *PolicyManagementAPIService) GetLevelPolicyExecute(r ApiGetLevelPolicyRequest) (*LevelPolicyDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LevelPolicyDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLevelPolicyBindingsRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	policyUuid interface{}
	levelId    interface{}
	levelType  interface{}
}

func (r ApiGetLevelPolicyBindingsRequest) Execute() (*LevelPolicyBindingDto, *http.Response, error) {
	return r.ApiService.GetLevelPolicyBindingsExecute(r)
}

/*
GetLevelPolicyBindings Get policy bindings within a level

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetLevelPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) GetLevelPolicyBindings(ctx context.Context, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiGetLevelPolicyBindingsRequest {
	return ApiGetLevelPolicyBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return LevelPolicyBindingDto
func (a *PolicyManagementAPIService) GetLevelPolicyBindingsExecute(r ApiGetLevelPolicyBindingsRequest) (*LevelPolicyBindingDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LevelPolicyBindingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetLevelPolicyBindings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLevelPolicyBindingsForGroupRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	groupUuid  interface{}
	policyUuid interface{}
	levelId    interface{}
	levelType  interface{}
}

func (r ApiGetLevelPolicyBindingsForGroupRequest) Execute() (*LevelPolicyBindingDto, *http.Response, error) {
	return r.ApiService.GetLevelPolicyBindingsForGroupExecute(r)
}

/*
GetLevelPolicyBindingsForGroup Get policy bindings within a level

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid The ID of the required user group.
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetLevelPolicyBindingsForGroupRequest
*/
func (a *PolicyManagementAPIService) GetLevelPolicyBindingsForGroup(ctx context.Context, groupUuid interface{}, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiGetLevelPolicyBindingsForGroupRequest {
	return ApiGetLevelPolicyBindingsForGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupUuid:  groupUuid,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return LevelPolicyBindingDto
func (a *PolicyManagementAPIService) GetLevelPolicyBindingsForGroupExecute(r ApiGetLevelPolicyBindingsForGroupRequest) (*LevelPolicyBindingDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LevelPolicyBindingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetLevelPolicyBindingsForGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLimitsForLevelRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	levelId    interface{}
	levelType  interface{}
}

func (r ApiGetLimitsForLevelRequest) Execute() (*LevelLimitsDto, *http.Response, error) {
	return r.ApiService.GetLimitsForLevelExecute(r)
}

/*
GetLimitsForLevel Returns limits defined for a level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetLimitsForLevelRequest
*/
func (a *PolicyManagementAPIService) GetLimitsForLevel(ctx context.Context, levelId interface{}, levelType interface{}) ApiGetLimitsForLevelRequest {
	return ApiGetLimitsForLevelRequest{
		ApiService: a,
		ctx:        ctx,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return LevelLimitsDto
func (a *PolicyManagementAPIService) GetLimitsForLevelExecute(r ApiGetLimitsForLevelRequest) (*LevelLimitsDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LevelLimitsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetLimitsForLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyBoundariesRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	accountId  interface{}
	size       *interface{}
	page       *interface{}
}

func (r ApiGetPolicyBoundariesRequest) Size(size interface{}) ApiGetPolicyBoundariesRequest {
	r.size = &size
	return r
}

func (r ApiGetPolicyBoundariesRequest) Page(page interface{}) ApiGetPolicyBoundariesRequest {
	r.page = &page
	return r
}

func (r ApiGetPolicyBoundariesRequest) Execute() (*PolicyBoundaryDtoList, *http.Response, error) {
	return r.ApiService.GetPolicyBoundariesExecute(r)
}

/*
GetPolicyBoundaries Get a list of policy boundaries within a level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId The ID of the policy boundary level. Use the UUID of the account.
	@return ApiGetPolicyBoundariesRequest
*/
func (a *PolicyManagementAPIService) GetPolicyBoundaries(ctx context.Context, accountId interface{}) ApiGetPolicyBoundariesRequest {
	return ApiGetPolicyBoundariesRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return PolicyBoundaryDtoList
func (a *PolicyManagementAPIService) GetPolicyBoundariesExecute(r ApiGetPolicyBoundariesRequest) (*PolicyBoundaryDtoList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyBoundaryDtoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetPolicyBoundaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/account/{accountId}/boundaries"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue interface{} = 100
		r.size = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue interface{} = 1
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyBoundaryRequest struct {
	ctx                context.Context
	ApiService         *PolicyManagementAPIService
	policyBoundaryUuid interface{}
	accountId          interface{}
}

func (r ApiGetPolicyBoundaryRequest) Execute() (*PolicyBoundaryOverview, *http.Response, error) {
	return r.ApiService.GetPolicyBoundaryExecute(r)
}

/*
GetPolicyBoundary Get policy boundary within a level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyBoundaryUuid The ID of the required boundary.
	@param accountId The ID of the policy boundary level. Use the UUID of the account.
	@return ApiGetPolicyBoundaryRequest
*/
func (a *PolicyManagementAPIService) GetPolicyBoundary(ctx context.Context, policyBoundaryUuid interface{}, accountId interface{}) ApiGetPolicyBoundaryRequest {
	return ApiGetPolicyBoundaryRequest{
		ApiService:         a,
		ctx:                ctx,
		policyBoundaryUuid: policyBoundaryUuid,
		accountId:          accountId,
	}
}

// Execute executes the request
//
//	@return PolicyBoundaryOverview
func (a *PolicyManagementAPIService) GetPolicyBoundaryExecute(r ApiGetPolicyBoundaryRequest) (*PolicyBoundaryOverview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyBoundaryOverview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetPolicyBoundary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/account/{accountId}/boundaries/{policyBoundaryUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyBoundaryUuid"+"}", url.PathEscape(parameterValueToString(r.policyBoundaryUuid, "policyBoundaryUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyOverviewListRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	levelId    interface{}
	levelType  interface{}
}

func (r ApiGetPolicyOverviewListRequest) Execute() (*PolicyOverviewDtoList, *http.Response, error) {
	return r.ApiService.GetPolicyOverviewListExecute(r)
}

/*
GetPolicyOverviewList Lists all policies for a level, including inherited from higher levels

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetPolicyOverviewListRequest
*/
func (a *PolicyManagementAPIService) GetPolicyOverviewList(ctx context.Context, levelId interface{}, levelType interface{}) ApiGetPolicyOverviewListRequest {
	return ApiGetPolicyOverviewListRequest{
		ApiService: a,
		ctx:        ctx,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return PolicyOverviewDtoList
func (a *PolicyManagementAPIService) GetPolicyOverviewListExecute(r ApiGetPolicyOverviewListRequest) (*PolicyOverviewDtoList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyOverviewDtoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetPolicyOverviewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/aggregate"
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyUuidsBindingsRequest struct {
	ctx        context.Context
	ApiService *PolicyManagementAPIService
	groupUuid  interface{}
	levelId    interface{}
	levelType  interface{}
	details    *interface{}
}

// Optional parameter to print-out additional details containing boundaries, metadata, parameters.
func (r ApiGetPolicyUuidsBindingsRequest) Details(details interface{}) ApiGetPolicyUuidsBindingsRequest {
	r.details = &details
	return r
}

func (r ApiGetPolicyUuidsBindingsRequest) Execute() (*PolicyUuidsWithoutMetadataDto, *http.Response, error) {
	return r.ApiService.GetPolicyUuidsBindingsExecute(r)
}

/*
GetPolicyUuidsBindings Lists all policies for a user group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid The ID of the required user group.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiGetPolicyUuidsBindingsRequest
*/
func (a *PolicyManagementAPIService) GetPolicyUuidsBindings(ctx context.Context, groupUuid interface{}, levelId interface{}, levelType interface{}) ApiGetPolicyUuidsBindingsRequest {
	return ApiGetPolicyUuidsBindingsRequest{
		ApiService: a,
		ctx:        ctx,
		groupUuid:  groupUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return PolicyUuidsWithoutMetadataDto
func (a *PolicyManagementAPIService) GetPolicyUuidsBindingsExecute(r ApiGetPolicyUuidsBindingsRequest) (*PolicyUuidsWithoutMetadataDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyUuidsWithoutMetadataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.GetPolicyUuidsBindings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/groups/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPolicyBoundaryRequest struct {
	ctx               context.Context
	ApiService        *PolicyManagementAPIService
	accountId         interface{}
	policyBoundaryDto *PolicyBoundaryDto
}

// The JSON body of the request. Contains new policy boundary
func (r ApiPostPolicyBoundaryRequest) PolicyBoundaryDto(policyBoundaryDto PolicyBoundaryDto) ApiPostPolicyBoundaryRequest {
	r.policyBoundaryDto = &policyBoundaryDto
	return r
}

func (r ApiPostPolicyBoundaryRequest) Execute() (*PolicyBoundaryOverview, *http.Response, error) {
	return r.ApiService.PostPolicyBoundaryExecute(r)
}

/*
PostPolicyBoundary Create a policy boundary within a level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId The ID of the policy boundary level. Use the UUID of the account.
	@return ApiPostPolicyBoundaryRequest
*/
func (a *PolicyManagementAPIService) PostPolicyBoundary(ctx context.Context, accountId interface{}) ApiPostPolicyBoundaryRequest {
	return ApiPostPolicyBoundaryRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return PolicyBoundaryOverview
func (a *PolicyManagementAPIService) PostPolicyBoundaryExecute(r ApiPostPolicyBoundaryRequest) (*PolicyBoundaryOverview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyBoundaryOverview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PostPolicyBoundary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/account/{accountId}/boundaries"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyBoundaryDto == nil {
		return localVarReturnValue, nil, reportError("policyBoundaryDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyBoundaryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutPolicyBoundaryRequest struct {
	ctx                context.Context
	ApiService         *PolicyManagementAPIService
	policyBoundaryUuid interface{}
	accountId          interface{}
	policyBoundaryDto  *PolicyBoundaryDto
}

// The JSON body of the request. Contains policy boundary
func (r ApiPutPolicyBoundaryRequest) PolicyBoundaryDto(policyBoundaryDto PolicyBoundaryDto) ApiPutPolicyBoundaryRequest {
	r.policyBoundaryDto = &policyBoundaryDto
	return r
}

func (r ApiPutPolicyBoundaryRequest) Execute() (*PolicyBoundaryOverview, *http.Response, error) {
	return r.ApiService.PutPolicyBoundaryExecute(r)
}

/*
PutPolicyBoundary Update or create a new policy boundary by uuid within a level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyBoundaryUuid The ID of the required boundary.
	@param accountId The ID of the policy boundary level. Use the UUID of the account.
	@return ApiPutPolicyBoundaryRequest
*/
func (a *PolicyManagementAPIService) PutPolicyBoundary(ctx context.Context, policyBoundaryUuid interface{}, accountId interface{}) ApiPutPolicyBoundaryRequest {
	return ApiPutPolicyBoundaryRequest{
		ApiService:         a,
		ctx:                ctx,
		policyBoundaryUuid: policyBoundaryUuid,
		accountId:          accountId,
	}
}

// Execute executes the request
//
//	@return PolicyBoundaryOverview
func (a *PolicyManagementAPIService) PutPolicyBoundaryExecute(r ApiPutPolicyBoundaryRequest) (*PolicyBoundaryOverview, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyBoundaryOverview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PutPolicyBoundary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/account/{accountId}/boundaries/{policyBoundaryUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyBoundaryUuid"+"}", url.PathEscape(parameterValueToString(r.policyBoundaryUuid, "policyBoundaryUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyBoundaryDto == nil {
		return localVarReturnValue, nil, reportError("policyBoundaryDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyBoundaryDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLevelPolicyRequest struct {
	ctx                                 context.Context
	ApiService                          *PolicyManagementAPIService
	policyUuid                          interface{}
	levelId                             interface{}
	levelType                           interface{}
	createOrUpdateLevelPolicyRequestDto *CreateOrUpdateLevelPolicyRequestDto
}

// The JSON body of the request. Contains the updated configuration of a policy.
func (r ApiUpdateLevelPolicyRequest) CreateOrUpdateLevelPolicyRequestDto(createOrUpdateLevelPolicyRequestDto CreateOrUpdateLevelPolicyRequestDto) ApiUpdateLevelPolicyRequest {
	r.createOrUpdateLevelPolicyRequestDto = &createOrUpdateLevelPolicyRequestDto
	return r
}

func (r ApiUpdateLevelPolicyRequest) Execute() (*LevelPolicyDto, *http.Response, error) {
	return r.ApiService.UpdateLevelPolicyExecute(r)
}

/*
UpdateLevelPolicy Updates a policy

If the specified policy doesn't exist, a new one is created.
This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiUpdateLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) UpdateLevelPolicy(ctx context.Context, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiUpdateLevelPolicyRequest {
	return ApiUpdateLevelPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return LevelPolicyDto
func (a *PolicyManagementAPIService) UpdateLevelPolicyExecute(r ApiUpdateLevelPolicyRequest) (*LevelPolicyDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LevelPolicyDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.UpdateLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateLevelPolicyRequestDto == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateLevelPolicyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateLevelPolicyRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest struct {
	ctx                                 context.Context
	ApiService                          *PolicyManagementAPIService
	groupUuid                           interface{}
	policyUuid                          interface{}
	levelId                             interface{}
	levelType                           interface{}
	appendLevelPolicyBindingForGroupDto *AppendLevelPolicyBindingForGroupDto
	queryParams                         *map[string]interface{}
}

// The JSON body of the request. Contains parameters, metadata and boundaries
func (r ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest) AppendLevelPolicyBindingForGroupDto(appendLevelPolicyBindingForGroupDto AppendLevelPolicyBindingForGroupDto) ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest {
	r.appendLevelPolicyBindingForGroupDto = &appendLevelPolicyBindingForGroupDto
	return r
}

// Key-value pairs for policy template parameters and metadata. Only bindings matching given parameters and metadata will be updated or deleted.
func (r ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest) QueryParams(queryParams map[string]interface{}) ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest {
	r.queryParams = &queryParams
	return r
}

func (r ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateLevelPolicyBindingForPolicyAndGroupExecute(r)
}

/*
UpdateLevelPolicyBindingForPolicyAndGroup Updates or creates a policy binding for a particular group and policy

This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid The ID of the required user group.
	@param policyUuid The ID of the required policy.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest
*/
func (a *PolicyManagementAPIService) UpdateLevelPolicyBindingForPolicyAndGroup(ctx context.Context, groupUuid interface{}, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest {
	return ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupUuid:  groupUuid,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) UpdateLevelPolicyBindingForPolicyAndGroupExecute(r ApiUpdateLevelPolicyBindingForPolicyAndGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.UpdateLevelPolicyBindingForPolicyAndGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appendLevelPolicyBindingForGroupDto == nil {
		return nil, reportError("appendLevelPolicyBindingForGroupDto is required and must be specified")
	}

	if r.queryParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query-params", r.queryParams, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appendLevelPolicyBindingForGroupDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdatePolicyBindingsToGroupRequest struct {
	ctx            context.Context
	ApiService     *PolicyManagementAPIService
	groupUuid      interface{}
	levelId        interface{}
	levelType      interface{}
	policyUuidsDto *PolicyUuidsDto
}

// The JSON body of the request. Contains new policies for the group.    Any policy not presented in the request is discarded.
func (r ApiUpdatePolicyBindingsToGroupRequest) PolicyUuidsDto(policyUuidsDto PolicyUuidsDto) ApiUpdatePolicyBindingsToGroupRequest {
	r.policyUuidsDto = &policyUuidsDto
	return r
}

func (r ApiUpdatePolicyBindingsToGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePolicyBindingsToGroupExecute(r)
}

/*
UpdatePolicyBindingsToGroup Updates policy bindings for a user group. The request overwrites an existing set of policy bindings

The request overwrites existing policies.
This endpoint is unavailable within global level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupUuid The ID of the required user group.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiUpdatePolicyBindingsToGroupRequest
*/
func (a *PolicyManagementAPIService) UpdatePolicyBindingsToGroup(ctx context.Context, groupUuid interface{}, levelId interface{}, levelType interface{}) ApiUpdatePolicyBindingsToGroupRequest {
	return ApiUpdatePolicyBindingsToGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupUuid:  groupUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) UpdatePolicyBindingsToGroupExecute(r ApiUpdatePolicyBindingsToGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.UpdatePolicyBindingsToGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/groups/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyUuidsDto == nil {
		return nil, reportError("policyUuidsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyUuidsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateLevelPolicyRequest struct {
	ctx                                 context.Context
	ApiService                          *PolicyManagementAPIService
	policyUuid                          interface{}
	levelId                             interface{}
	levelType                           interface{}
	createOrUpdateLevelPolicyRequestDto *CreateOrUpdateLevelPolicyRequestDto
}

// The JSON body of the request. Contains the configuration of a policy to be validated.
func (r ApiValidateLevelPolicyRequest) CreateOrUpdateLevelPolicyRequestDto(createOrUpdateLevelPolicyRequestDto CreateOrUpdateLevelPolicyRequestDto) ApiValidateLevelPolicyRequest {
	r.createOrUpdateLevelPolicyRequestDto = &createOrUpdateLevelPolicyRequestDto
	return r
}

func (r ApiValidateLevelPolicyRequest) Execute() (*ValidationDto, *http.Response, error) {
	return r.ApiService.ValidateLevelPolicyExecute(r)
}

/*
ValidateLevelPolicy Validates the payload for the `PUT /iam/v1/repo/{levelType}/{levelId}/policies/{policyUuid}` request

This endpoint is unavailable within global level. Validation moved to create/update policy endpoints.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The ID of the policy to be validated.
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiValidateLevelPolicyRequest

Deprecated
*/
func (a *PolicyManagementAPIService) ValidateLevelPolicy(ctx context.Context, policyUuid interface{}, levelId interface{}, levelType interface{}) ApiValidateLevelPolicyRequest {
	return ApiValidateLevelPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		policyUuid: policyUuid,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return ValidationDto
//
// Deprecated
func (a *PolicyManagementAPIService) ValidateLevelPolicyExecute(r ApiValidateLevelPolicyRequest) (*ValidationDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.ValidateLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/validation/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateLevelPolicyRequestDto == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateLevelPolicyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateLevelPolicyRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateNewLevelPolicyRequest struct {
	ctx                                 context.Context
	ApiService                          *PolicyManagementAPIService
	levelId                             interface{}
	levelType                           interface{}
	createOrUpdateLevelPolicyRequestDto *CreateOrUpdateLevelPolicyRequestDto
}

// The JSON body of the request. Contains the configuration of a policy to be validated.
func (r ApiValidateNewLevelPolicyRequest) CreateOrUpdateLevelPolicyRequestDto(createOrUpdateLevelPolicyRequestDto CreateOrUpdateLevelPolicyRequestDto) ApiValidateNewLevelPolicyRequest {
	r.createOrUpdateLevelPolicyRequestDto = &createOrUpdateLevelPolicyRequestDto
	return r
}

func (r ApiValidateNewLevelPolicyRequest) Execute() (*ValidationDto, *http.Response, error) {
	return r.ApiService.ValidateNewLevelPolicyExecute(r)
}

/*
ValidateNewLevelPolicy Validates the payload for the `POST /iam/v1/repo/{levelType}/{levelId}/policies` request

This endpoint is unavailable within global level. Validation moved to create/update policy endpoints.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
	@param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
	@return ApiValidateNewLevelPolicyRequest

Deprecated
*/
func (a *PolicyManagementAPIService) ValidateNewLevelPolicy(ctx context.Context, levelId interface{}, levelType interface{}) ApiValidateNewLevelPolicyRequest {
	return ApiValidateNewLevelPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		levelId:    levelId,
		levelType:  levelType,
	}
}

// Execute executes the request
//
//	@return ValidationDto
//
// Deprecated
func (a *PolicyManagementAPIService) ValidateNewLevelPolicyExecute(r ApiValidateNewLevelPolicyRequest) (*ValidationDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.ValidateNewLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/validation"
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateLevelPolicyRequestDto == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateLevelPolicyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateLevelPolicyRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
