/*
Dynatrace Account Management API

The enterprise management API for Dynatrace SaaS enables automation of operational tasks related to user access and environment lifecycle management.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package accountmanagement

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// DynatracePlatformSubscriptionPriorToApril2023APIService DynatracePlatformSubscriptionPriorToApril2023API service
type DynatracePlatformSubscriptionPriorToApril2023APIService service

type ApiAddClaBudgetLimitForClusterRequest struct {
	ctx               context.Context
	ApiService        *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid       string
	subscriptionId    float32
	clusterUuid       string
	claBudgetLimitDto *ClaBudgetLimitDto
}

// The JSON body of the request. Contains the new limit for the cluster.
func (r ApiAddClaBudgetLimitForClusterRequest) ClaBudgetLimitDto(claBudgetLimitDto ClaBudgetLimitDto) ApiAddClaBudgetLimitForClusterRequest {
	r.claBudgetLimitDto = &claBudgetLimitDto
	return r
}

func (r ApiAddClaBudgetLimitForClusterRequest) Execute() (*ClaBudgetLimitRecordsDto, *http.Response, error) {
	return r.ApiService.AddClaBudgetLimitForClusterExecute(r)
}

/*
AddClaBudgetLimitForCluster Creates a limit for a cluster

[Limits](https://dt-url.net/yz03uq5) help you control the usage of your annual [commit](https://dt-url.net/i503u3z).

If no limit is set, the commit is consumed until it is exhausted. If the consumption on the cluster exceeds the limit, the cluster will stop the monitoring.

The endpoint is available only for Dynatrace Managed accounts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@param clusterUuid The ID of the cluster where you want to set the limit.   Fetch the list of clusters with the [GET clusters](https://dt-url.net/3q03uao) request.
	@return ApiAddClaBudgetLimitForClusterRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) AddClaBudgetLimitForCluster(ctx context.Context, accountUuid string, subscriptionId float32, clusterUuid string) ApiAddClaBudgetLimitForClusterRequest {
	return ApiAddClaBudgetLimitForClusterRequest{
		ApiService:     a,
		ctx:            ctx,
		accountUuid:    accountUuid,
		subscriptionId: subscriptionId,
		clusterUuid:    clusterUuid,
	}
}

// Execute executes the request
//
//	@return ClaBudgetLimitRecordsDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) AddClaBudgetLimitForClusterExecute(r ApiAddClaBudgetLimitForClusterRequest) (*ClaBudgetLimitRecordsDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaBudgetLimitRecordsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.AddClaBudgetLimitForCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/clusters/{clusterUuid}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clusterUuid"+"}", url.PathEscape(parameterValueToString(r.clusterUuid, "clusterUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.claBudgetLimitDto == nil {
		return localVarReturnValue, nil, reportError("claBudgetLimitDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.claBudgetLimitDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddClaBudgetLimitForEnvironmentRequest struct {
	ctx               context.Context
	ApiService        *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid       string
	subscriptionId    float32
	environmentUuid   string
	claBudgetLimitDto *ClaBudgetLimitDto
}

// The JSON body of the request. Contains the new limit for the environment.
func (r ApiAddClaBudgetLimitForEnvironmentRequest) ClaBudgetLimitDto(claBudgetLimitDto ClaBudgetLimitDto) ApiAddClaBudgetLimitForEnvironmentRequest {
	r.claBudgetLimitDto = &claBudgetLimitDto
	return r
}

func (r ApiAddClaBudgetLimitForEnvironmentRequest) Execute() (*ClaBudgetLimitRecordsDto, *http.Response, error) {
	return r.ApiService.AddClaBudgetLimitForEnvironmentExecute(r)
}

/*
AddClaBudgetLimitForEnvironment Creates a limit for an environment

[Limits](https://dt-url.net/yz03uq5) help you control the usage of your annual [commit](https://dt-url.net/i503u3z).

If no limit is set, the commit is consumed until it is exhausted. If the consumption on the environment exceeds the limit, the environment will stop the monitoring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@param environmentUuid The ID of the environment where you want to set the limit.   Fetch the list of environments with the [GET environments](https://dt-url.net/6823uuy) request.
	@return ApiAddClaBudgetLimitForEnvironmentRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) AddClaBudgetLimitForEnvironment(ctx context.Context, accountUuid string, subscriptionId float32, environmentUuid string) ApiAddClaBudgetLimitForEnvironmentRequest {
	return ApiAddClaBudgetLimitForEnvironmentRequest{
		ApiService:      a,
		ctx:             ctx,
		accountUuid:     accountUuid,
		subscriptionId:  subscriptionId,
		environmentUuid: environmentUuid,
	}
}

// Execute executes the request
//
//	@return ClaBudgetLimitRecordsDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) AddClaBudgetLimitForEnvironmentExecute(r ApiAddClaBudgetLimitForEnvironmentRequest) (*ClaBudgetLimitRecordsDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaBudgetLimitRecordsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.AddClaBudgetLimitForEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/environments/{environmentUuid}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentUuid"+"}", url.PathEscape(parameterValueToString(r.environmentUuid, "environmentUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.claBudgetLimitDto == nil {
		return localVarReturnValue, nil, reportError("claBudgetLimitDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.claBudgetLimitDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaBudgetLimitsRequest struct {
	ctx            context.Context
	ApiService     *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid    string
	subscriptionId float32
}

func (r ApiGetClaBudgetLimitsRequest) Execute() (*ClaBudgetLimitRecordListDto, *http.Response, error) {
	return r.ApiService.GetClaBudgetLimitsExecute(r)
}

/*
GetClaBudgetLimits Lists limits for a subscription

[Limits](https://dt-url.net/yz03uq5) help you control the usage of your annual [commit](https://dt-url.net/i503u3z).

If no limit is set, the commit is consumed until it is exhausted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@return ApiGetClaBudgetLimitsRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaBudgetLimits(ctx context.Context, accountUuid string, subscriptionId float32) ApiGetClaBudgetLimitsRequest {
	return ApiGetClaBudgetLimitsRequest{
		ApiService:     a,
		ctx:            ctx,
		accountUuid:    accountUuid,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//
//	@return ClaBudgetLimitRecordListDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaBudgetLimitsExecute(r ApiGetClaBudgetLimitsRequest) (*ClaBudgetLimitRecordListDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaBudgetLimitRecordListDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.GetClaBudgetLimits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaLicenseDetailsByIdRequest struct {
	ctx            context.Context
	ApiService     *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid    string
	subscriptionId float32
}

func (r ApiGetClaLicenseDetailsByIdRequest) Execute() (*ClaSubscriptionTermDto, *http.Response, error) {
	return r.ApiService.GetClaLicenseDetailsByIdExecute(r)
}

/*
GetClaLicenseDetailsById Gets the active term of a subscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@return ApiGetClaLicenseDetailsByIdRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaLicenseDetailsById(ctx context.Context, accountUuid string, subscriptionId float32) ApiGetClaLicenseDetailsByIdRequest {
	return ApiGetClaLicenseDetailsByIdRequest{
		ApiService:     a,
		ctx:            ctx,
		accountUuid:    accountUuid,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//
//	@return ClaSubscriptionTermDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaLicenseDetailsByIdExecute(r ApiGetClaLicenseDetailsByIdRequest) (*ClaSubscriptionTermDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaSubscriptionTermDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.GetClaLicenseDetailsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/term"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaSubscriptionClusterDetailsRequest struct {
	ctx         context.Context
	ApiService  *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid string
}

func (r ApiGetClaSubscriptionClusterDetailsRequest) Execute() (*ClaClusterListDto, *http.Response, error) {
	return r.ApiService.GetClaSubscriptionClusterDetailsExecute(r)
}

/*
GetClaSubscriptionClusterDetails Lists all clusters of an account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@return ApiGetClaSubscriptionClusterDetailsRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaSubscriptionClusterDetails(ctx context.Context, accountUuid string) ApiGetClaSubscriptionClusterDetailsRequest {
	return ApiGetClaSubscriptionClusterDetailsRequest{
		ApiService:  a,
		ctx:         ctx,
		accountUuid: accountUuid,
	}
}

// Execute executes the request
//
//	@return ClaClusterListDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaSubscriptionClusterDetailsExecute(r ApiGetClaSubscriptionClusterDetailsRequest) (*ClaClusterListDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaClusterListDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.GetClaSubscriptionClusterDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/clusters"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaSubscriptionEnvironmentDetailsRequest struct {
	ctx         context.Context
	ApiService  *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid string
}

func (r ApiGetClaSubscriptionEnvironmentDetailsRequest) Execute() (*ClaEnvironmentListDto, *http.Response, error) {
	return r.ApiService.GetClaSubscriptionEnvironmentDetailsExecute(r)
}

/*
GetClaSubscriptionEnvironmentDetails Lists all clusters of an account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@return ApiGetClaSubscriptionEnvironmentDetailsRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaSubscriptionEnvironmentDetails(ctx context.Context, accountUuid string) ApiGetClaSubscriptionEnvironmentDetailsRequest {
	return ApiGetClaSubscriptionEnvironmentDetailsRequest{
		ApiService:  a,
		ctx:         ctx,
		accountUuid: accountUuid,
	}
}

// Execute executes the request
//
//	@return ClaEnvironmentListDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaSubscriptionEnvironmentDetailsExecute(r ApiGetClaSubscriptionEnvironmentDetailsRequest) (*ClaEnvironmentListDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaEnvironmentListDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.GetClaSubscriptionEnvironmentDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/environments"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClaSubscriptionsRequest struct {
	ctx         context.Context
	ApiService  *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid string
}

func (r ApiGetClaSubscriptionsRequest) Execute() (*ClaSubscriptionListDto, *http.Response, error) {
	return r.ApiService.GetClaSubscriptionsExecute(r)
}

/*
GetClaSubscriptions Lists all Dynatrace platform subscriptions of an account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@return ApiGetClaSubscriptionsRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaSubscriptions(ctx context.Context, accountUuid string) ApiGetClaSubscriptionsRequest {
	return ApiGetClaSubscriptionsRequest{
		ApiService:  a,
		ctx:         ctx,
		accountUuid: accountUuid,
	}
}

// Execute executes the request
//
//	@return ClaSubscriptionListDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClaSubscriptionsExecute(r ApiGetClaSubscriptionsRequest) (*ClaSubscriptionListDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaSubscriptionListDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.GetClaSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClusterLevelClaLicenseConsumptionDataRequest struct {
	ctx             context.Context
	ApiService      *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid     string
	subscriptionId  float32
	resolution      *string
	calculationMode *string
	clusterUuids    *[]string
	from            *string
	to              *string
}

// The resolution at which you want to see the consumption. You have the following options:   * &#x60;HOURLY&#x60;: the consumption for each full hour. Requires **to** and **from** paramters to be set. The hourly resolution is only available for consumption within the last 30 days.  * &#x60;DAILY&#x60;: the consumption for each calendar day. Requires **to** and **from** paramters to be set.  * &#x60;SUBSCRIPTION_MONTHLY&#x60;: the consumption for each subscription month. A subscription month always starts on the same day of the month your subscription started.  * &#x60;SUBSCRIPTION_YEAR&#x60;: the consumption for a complete subscription year. A subscription year always starts on the same date your subscription started.
func (r ApiGetClusterLevelClaLicenseConsumptionDataRequest) Resolution(resolution string) ApiGetClusterLevelClaLicenseConsumptionDataRequest {
	r.resolution = &resolution
	return r
}

// The calculation mode at which you want the consumption to return. RATED consumption (default) is returned in DPS units according to your rate card. UNRATED consumption is returned in the consumed native units, for example Host Unit Hours and the rate card is not applied.
func (r ApiGetClusterLevelClaLicenseConsumptionDataRequest) CalculationMode(calculationMode string) ApiGetClusterLevelClaLicenseConsumptionDataRequest {
	r.calculationMode = &calculationMode
	return r
}

// Filter the result to specified clusters only. To specify several IDs, use the following format: &#x60;clusterUuids&#x3D;ID1&amp;clusterUuids&#x3D;ID2&#x60;.   You can fetch the list of clusters with the [GET clusters](https://dt-url.net/3q03uao) request.
func (r ApiGetClusterLevelClaLicenseConsumptionDataRequest) ClusterUuids(clusterUuids []string) ApiGetClusterLevelClaLicenseConsumptionDataRequest {
	r.clusterUuids = &clusterUuids
	return r
}

// The start of the requested timeframe in &#x60;2021-05-01T15:11:00Z&#x60; format.
func (r ApiGetClusterLevelClaLicenseConsumptionDataRequest) From(from string) ApiGetClusterLevelClaLicenseConsumptionDataRequest {
	r.from = &from
	return r
}

// The end of the requested timeframe in &#x60;2021-05-01T15:11:00Z&#x60; format.
func (r ApiGetClusterLevelClaLicenseConsumptionDataRequest) To(to string) ApiGetClusterLevelClaLicenseConsumptionDataRequest {
	r.to = &to
	return r
}

func (r ApiGetClusterLevelClaLicenseConsumptionDataRequest) Execute() ([]ClusterOrEnvironmentAggregatedReturnDto, *http.Response, error) {
	return r.ApiService.GetClusterLevelClaLicenseConsumptionDataExecute(r)
}

/*
GetClusterLevelClaLicenseConsumptionData Gets the cluster-level consumption of a subscription

The endpoint is available only for Dynatrace Managed accounts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@return ApiGetClusterLevelClaLicenseConsumptionDataRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClusterLevelClaLicenseConsumptionData(ctx context.Context, accountUuid string, subscriptionId float32) ApiGetClusterLevelClaLicenseConsumptionDataRequest {
	return ApiGetClusterLevelClaLicenseConsumptionDataRequest{
		ApiService:     a,
		ctx:            ctx,
		accountUuid:    accountUuid,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//
//	@return []ClusterOrEnvironmentAggregatedReturnDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetClusterLevelClaLicenseConsumptionDataExecute(r ApiGetClusterLevelClaLicenseConsumptionDataRequest) ([]ClusterOrEnvironmentAggregatedReturnDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ClusterOrEnvironmentAggregatedReturnDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.GetClusterLevelClaLicenseConsumptionData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/clusters/consumption"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resolution == nil {
		return localVarReturnValue, nil, reportError("resolution is required and must be specified")
	}
	if r.calculationMode == nil {
		return localVarReturnValue, nil, reportError("calculationMode is required and must be specified")
	}

	if r.clusterUuids != nil {
		t := *r.clusterUuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "clusterUuids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "clusterUuids", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "resolution", r.resolution, "form", "")
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "calculationMode", r.calculationMode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProductLevelClaLicenseConsumptionDataRequest struct {
	ctx             context.Context
	ApiService      *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid     string
	subscriptionId  float32
	resolution      *string
	calculationMode *string
	from            *string
	to              *string
}

// The resolution at which you want to see the consumption. You have the following options:   * &#x60;HOURLY&#x60;: the consumption for each full hour. Requires **to** and **from** paramters to be set. The hourly resolution is only available for consumption within the last 30 days.  * &#x60;DAILY&#x60;: the consumption for each calendar day. Requires **to** and **from** paramters to be set.  * &#x60;SUBSCRIPTION_MONTHLY&#x60;: the consumption for each subscription month. A subscription month always starts on the same day of the month your subscription started.  * &#x60;SUBSCRIPTION_YEAR&#x60;: the consumption for a complete subscription year. A subscription year always starts on the same date your subscription started.
func (r ApiGetProductLevelClaLicenseConsumptionDataRequest) Resolution(resolution string) ApiGetProductLevelClaLicenseConsumptionDataRequest {
	r.resolution = &resolution
	return r
}

// The calculation mode at which you want the consumption to return. RATED consumption (default) is returned in DPS units according to your rate card. UNRATED consumption is returned in the consumed native units, for example Host Unit Hours and the rate card is not applied.
func (r ApiGetProductLevelClaLicenseConsumptionDataRequest) CalculationMode(calculationMode string) ApiGetProductLevelClaLicenseConsumptionDataRequest {
	r.calculationMode = &calculationMode
	return r
}

// The start of the requested timeframe in &#x60;2021-05-01T15:11:00Z&#x60; format.
func (r ApiGetProductLevelClaLicenseConsumptionDataRequest) From(from string) ApiGetProductLevelClaLicenseConsumptionDataRequest {
	r.from = &from
	return r
}

// The end of the requested timeframe in &#x60;2021-05-01T15:11:00Z&#x60; format.
func (r ApiGetProductLevelClaLicenseConsumptionDataRequest) To(to string) ApiGetProductLevelClaLicenseConsumptionDataRequest {
	r.to = &to
	return r
}

func (r ApiGetProductLevelClaLicenseConsumptionDataRequest) Execute() (*ConsumptionReturnListDto, *http.Response, error) {
	return r.ApiService.GetProductLevelClaLicenseConsumptionDataExecute(r)
}

/*
GetProductLevelClaLicenseConsumptionData Gets the consumption of a subscription

You can narrow down the output by specifying the timeframe during which the consumption happened.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@return ApiGetProductLevelClaLicenseConsumptionDataRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetProductLevelClaLicenseConsumptionData(ctx context.Context, accountUuid string, subscriptionId float32) ApiGetProductLevelClaLicenseConsumptionDataRequest {
	return ApiGetProductLevelClaLicenseConsumptionDataRequest{
		ApiService:     a,
		ctx:            ctx,
		accountUuid:    accountUuid,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//
//	@return ConsumptionReturnListDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetProductLevelClaLicenseConsumptionDataExecute(r ApiGetProductLevelClaLicenseConsumptionDataRequest) (*ConsumptionReturnListDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConsumptionReturnListDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.GetProductLevelClaLicenseConsumptionData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/consumption"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resolution == nil {
		return localVarReturnValue, nil, reportError("resolution is required and must be specified")
	}
	if r.calculationMode == nil {
		return localVarReturnValue, nil, reportError("calculationMode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "resolution", r.resolution, "form", "")
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "calculationMode", r.calculationMode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTenantLevelClaLicenseConsumptionDataRequest struct {
	ctx              context.Context
	ApiService       *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid      string
	subscriptionId   float32
	resolution       *string
	calculationMode  *string
	environmentUuids *[]string
	from             *string
	to               *string
}

// The resolution at which you want to see the consumption. You have the following options:   * &#x60;HOURLY&#x60;: the consumption for each full hour. Requires **to** and **from** paramters to be set. The hourly resolution is only available for consumption within the last 30 days.  * &#x60;DAILY&#x60;: the consumption for each calendar day. Requires **to** and **from** paramters to be set.  * &#x60;SUBSCRIPTION_MONTHLY&#x60;: the consumption for each subscription month. A subscription month always starts on the same day of the month your subscription started.  * &#x60;SUBSCRIPTION_YEAR&#x60;: the consumption for a complete subscription year. A subscription year always starts on the same date your subscription started.
func (r ApiGetTenantLevelClaLicenseConsumptionDataRequest) Resolution(resolution string) ApiGetTenantLevelClaLicenseConsumptionDataRequest {
	r.resolution = &resolution
	return r
}

// The calculation mode at which you want the consumption to return. RATED consumption (default) is returned in DPS units according to your rate card. UNRATED consumption is returned in the consumed native units, for example Host Unit Hours and the rate card is not applied.
func (r ApiGetTenantLevelClaLicenseConsumptionDataRequest) CalculationMode(calculationMode string) ApiGetTenantLevelClaLicenseConsumptionDataRequest {
	r.calculationMode = &calculationMode
	return r
}

// Filter the result to specified environments only. To specify several IDs, use the following format: &#x60;environmentUuids&#x3D;ID1&amp;environmentUuids&#x3D;ID2&#x60;.   You can fetch the list of environments with the [GET environments](https://dt-url.net/6823uuy) request.
func (r ApiGetTenantLevelClaLicenseConsumptionDataRequest) EnvironmentUuids(environmentUuids []string) ApiGetTenantLevelClaLicenseConsumptionDataRequest {
	r.environmentUuids = &environmentUuids
	return r
}

// The start of the requested timeframe in &#x60;2021-05-01T15:11:00Z&#x60; format.
func (r ApiGetTenantLevelClaLicenseConsumptionDataRequest) From(from string) ApiGetTenantLevelClaLicenseConsumptionDataRequest {
	r.from = &from
	return r
}

// The end of the requested timeframe in &#x60;2021-05-01T15:11:00Z&#x60; format.
func (r ApiGetTenantLevelClaLicenseConsumptionDataRequest) To(to string) ApiGetTenantLevelClaLicenseConsumptionDataRequest {
	r.to = &to
	return r
}

func (r ApiGetTenantLevelClaLicenseConsumptionDataRequest) Execute() ([]ClusterOrEnvironmentAggregatedReturnDto, *http.Response, error) {
	return r.ApiService.GetTenantLevelClaLicenseConsumptionDataExecute(r)
}

/*
GetTenantLevelClaLicenseConsumptionData Gets the environment-level consumption of a subscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@return ApiGetTenantLevelClaLicenseConsumptionDataRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetTenantLevelClaLicenseConsumptionData(ctx context.Context, accountUuid string, subscriptionId float32) ApiGetTenantLevelClaLicenseConsumptionDataRequest {
	return ApiGetTenantLevelClaLicenseConsumptionDataRequest{
		ApiService:     a,
		ctx:            ctx,
		accountUuid:    accountUuid,
		subscriptionId: subscriptionId,
	}
}

// Execute executes the request
//
//	@return []ClusterOrEnvironmentAggregatedReturnDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) GetTenantLevelClaLicenseConsumptionDataExecute(r ApiGetTenantLevelClaLicenseConsumptionDataRequest) ([]ClusterOrEnvironmentAggregatedReturnDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ClusterOrEnvironmentAggregatedReturnDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.GetTenantLevelClaLicenseConsumptionData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/environments/consumption"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resolution == nil {
		return localVarReturnValue, nil, reportError("resolution is required and must be specified")
	}
	if r.calculationMode == nil {
		return localVarReturnValue, nil, reportError("calculationMode is required and must be specified")
	}

	if r.environmentUuids != nil {
		t := *r.environmentUuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "environmentUuids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "environmentUuids", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "resolution", r.resolution, "form", "")
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "calculationMode", r.calculationMode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateClaBudgetLimitForClusterRequest struct {
	ctx               context.Context
	ApiService        *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid       string
	subscriptionId    float32
	clusterUuid       string
	claBudgetLimitDto *ClaBudgetLimitDto
}

func (r ApiUpdateClaBudgetLimitForClusterRequest) ClaBudgetLimitDto(claBudgetLimitDto ClaBudgetLimitDto) ApiUpdateClaBudgetLimitForClusterRequest {
	r.claBudgetLimitDto = &claBudgetLimitDto
	return r
}

func (r ApiUpdateClaBudgetLimitForClusterRequest) Execute() (*ClaBudgetLimitRecordsDto, *http.Response, error) {
	return r.ApiService.UpdateClaBudgetLimitForClusterExecute(r)
}

/*
UpdateClaBudgetLimitForCluster Updates the limit for a cluster

[Limits](https://dt-url.net/yz03uq5) help you control the usage of your annual [commit](https://dt-url.net/i503u3z).

If no limit is set, the commit is consumed until it is exhausted. If the consumption on the cluster exceeds the limit, the cluster will stop the monitoring.

The endpoint is available only for Dynatrace Managed accounts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@param clusterUuid The ID of the cluster where you want to set the limit.   Fetch the list of clusters with the [GET clusters](https://dt-url.net/3q03uao) request.
	@return ApiUpdateClaBudgetLimitForClusterRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) UpdateClaBudgetLimitForCluster(ctx context.Context, accountUuid string, subscriptionId float32, clusterUuid string) ApiUpdateClaBudgetLimitForClusterRequest {
	return ApiUpdateClaBudgetLimitForClusterRequest{
		ApiService:     a,
		ctx:            ctx,
		accountUuid:    accountUuid,
		subscriptionId: subscriptionId,
		clusterUuid:    clusterUuid,
	}
}

// Execute executes the request
//
//	@return ClaBudgetLimitRecordsDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) UpdateClaBudgetLimitForClusterExecute(r ApiUpdateClaBudgetLimitForClusterRequest) (*ClaBudgetLimitRecordsDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaBudgetLimitRecordsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.UpdateClaBudgetLimitForCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/clusters/{clusterUuid}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clusterUuid"+"}", url.PathEscape(parameterValueToString(r.clusterUuid, "clusterUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.claBudgetLimitDto == nil {
		return localVarReturnValue, nil, reportError("claBudgetLimitDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.claBudgetLimitDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateClaBudgetLimitForEnvironmentRequest struct {
	ctx               context.Context
	ApiService        *DynatracePlatformSubscriptionPriorToApril2023APIService
	accountUuid       string
	subscriptionId    float32
	environmentUuid   string
	claBudgetLimitDto *ClaBudgetLimitDto
}

func (r ApiUpdateClaBudgetLimitForEnvironmentRequest) ClaBudgetLimitDto(claBudgetLimitDto ClaBudgetLimitDto) ApiUpdateClaBudgetLimitForEnvironmentRequest {
	r.claBudgetLimitDto = &claBudgetLimitDto
	return r
}

func (r ApiUpdateClaBudgetLimitForEnvironmentRequest) Execute() (*ClaBudgetLimitRecordsDto, *http.Response, error) {
	return r.ApiService.UpdateClaBudgetLimitForEnvironmentExecute(r)
}

/*
UpdateClaBudgetLimitForEnvironment Updates the limit for an environment

[Limits](https://dt-url.net/yz03uq5) help you control the usage of your annual [commit](https://dt-url.net/i503u3z).

If no limit is set, the commit is consumed until it is exhausted. If the consumption on the environment exceeds the limit, the environment will stop the monitoring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountUuid The ID of the required account.    You can find the UUID on the **Account Management** > **Identity & access management** > **OAuth clients** page, during creation of an OAuth client.
	@param subscriptionId The ID of the required subscription.    Fetch the list of subscriptions with the [GET subscriptions](https://dt-url.net/qd43uld) call.
	@param environmentUuid The ID of the environment where you want to set the limit.   Fetch the list of environments with the [GET environments](https://dt-url.net/6823uuy) request.
	@return ApiUpdateClaBudgetLimitForEnvironmentRequest
*/
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) UpdateClaBudgetLimitForEnvironment(ctx context.Context, accountUuid string, subscriptionId float32, environmentUuid string) ApiUpdateClaBudgetLimitForEnvironmentRequest {
	return ApiUpdateClaBudgetLimitForEnvironmentRequest{
		ApiService:      a,
		ctx:             ctx,
		accountUuid:     accountUuid,
		subscriptionId:  subscriptionId,
		environmentUuid: environmentUuid,
	}
}

// Execute executes the request
//
//	@return ClaBudgetLimitRecordsDto
func (a *DynatracePlatformSubscriptionPriorToApril2023APIService) UpdateClaBudgetLimitForEnvironmentExecute(r ApiUpdateClaBudgetLimitForEnvironmentRequest) (*ClaBudgetLimitRecordsDto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ClaBudgetLimitRecordsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynatracePlatformSubscriptionPriorToApril2023APIService.UpdateClaBudgetLimitForEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sub/v1/accounts/{accountUuid}/subscriptions/{subscriptionId}/environments/{environmentUuid}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"accountUuid"+"}", url.PathEscape(parameterValueToString(r.accountUuid, "accountUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionId"+"}", url.PathEscape(parameterValueToString(r.subscriptionId, "subscriptionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentUuid"+"}", url.PathEscape(parameterValueToString(r.environmentUuid, "environmentUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.claBudgetLimitDto == nil {
		return localVarReturnValue, nil, reportError("claBudgetLimitDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.claBudgetLimitDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
